#pragma config(Sensor, S1,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S2,     leftSonar,      sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     color,          sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     rightSonar,     sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "HitechnicColorSensor.h"
int LIGHTTHRESH = 800;
int TURNTHRESHOLD = 45;
int position = 0;
bool found = false;
bool object = false;
bool turned = false;
bool reset = false;
bool lap = false;
bool atTurn = false;
int lapTurns = 0;
int lm = 5;
int rm = 7;
int currentGyro;
int lastTurnGyro = 0;
int startGyro = 0;
int currentEncoderDistance; //From last turn
int bestEncoderDistance = 0;
int bestLine;
int turnNum = 0;

/** Measures the distance traveled between each turn and the turn before the longest straight
		once the robot makes it back to that turn go half of the length**/
task observe(){

	//Reset all counters and gyro readings once a line is found
	if(found && !reset){
			clearTimer(T1);

			lastTurnGyro = getGyroDegrees(gyro);
			startGyro = lastTurnGyro;
			bestLine = 0;
			turnNum = 0;
			bestEncoderDistance = 0;
			currentEncoderDistance = 0;
			resetMotorEncoder(leftMotor);
			resetMotorEncoder(rightMotor);
			reset = true;
	}

	//Ignore the first second of finding a line to not mark it as a turn
	if(time1[T1] > 500 && time1[T1] < 1000){
		turnNum = 0;
	}

	//update gyro
	currentGyro = getGyroDegrees(gyro);

	/* Checks if the robot has turned and if so was the distance between turns longer then the current best */
	if(currentGyro < lastTurnGyro - TURNTHRESHOLD || currentGyro > lastTurnGyro + TURNTHRESHOLD){ //If theres a turn
		lastTurnGyro = currentGyro; //Update gyro
		turnNum++; //Increment turn num
		currentEncoderDistance = getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor); //getCurrentMotorDistance

		if(currentEncoderDistance > bestEncoderDistance){ //If traveled further
			bestEncoderDistance = currentEncoderDistance; //Update best encoder
			bestLine = turnNum; //The turn before the best line
		}

		//Reset encoders for the next stright
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
	}

	/* Checks if the robot has done a lap of the track */
	if(!lap && (((currentGyro <= startGyro + 360 + TURNTHRESHOLD) && (currentGyro >= startGyro + 360 - TURNTHRESHOLD)) || ((currentGyro <= startGyro - 360 + TURNTHRESHOLD) && (currentGyro >= startGyro - 360 - TURNTHRESHOLD)))){
		lap = true;
		lapTurns = turnNum;
		turnNum = 0;
		displayTextLine(5, "LAP");
	}

	/* If its done a lap and gone to first turn go to longest path */
	if(lap && !atTurn && turnNum >= bestLine){
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
		displayTextLine(6, "AT LINE");
		atTurn = true;
	}

	/* if it is half way on the line stop*/
	if(atTurn && lap && getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor) >= bestEncoderDistance / 2){
		displayTextLine(7, "STOP!");
		stopAllTasks();
	}

	//Display readings
	displayTextLine(3, "currentGyro %d, last gyro %d", currentGyro, lastTurnGyro);
	displayTextLine(4, "TurnNum %d, Best turn: %d", turnNum, bestLine);

}

/** Detects an object within 5cm, back up and turn round the object **/
task avoid(){

	//if theres an object in 5cm clear timer
	if((getUSDistance(S2) < 5 || getUSDistance(S4) < 5)){
		object = true;
		clearTimer(T4);
	}


	if(object == true){

		//if theres an object after 6 seconds reset bools.
		if(time1[T4] >= 6000){
			object = false;
			turned = false;
		}

		//If theres another object turn again
		if(turned == true && (getUSDistance(S2) < 5 || getUSDistance(S4) < 5)){
			turned = false;
		}

	}

}

/** If the robot is not on a line, turn in a circle **/
task findLine(){

	long r, g, b;
	HTCS2readRawRGB(S3, true, r, g, b);

	if(!found && !object){ //Turn

		if(g < LIGHTTHRESH){ //Found a line

			lm = 5;
			rm = 7;
			clearTimer(T2);

			found = true;
			clearTimer(T2);

		}
	}

}

task lineFollow(){

	long r, g, b;
	HTCS2readRawRGB(S3, true, r, g, b);

	if(found && !object){
		if(g <= LIGHTTHRESH){ //On black
			position = 0;
			clearTimer(T2);
		}else if(g > LIGHTTHRESH){ //off
			position = 1;
		}
		if(time1[T2] > 3000){
				found = false;
		}
	}

	displayTextLine(0, "R: %d G: %d B: %d", r, g, b);

}

void init(){
	long r, g, b;

	clearTimer(T1);
	while(time1[T1] < 5000){
		HTCS2readRawRGB(S3, true, r, g, b);
		displayTextLine(5, "Hold in black g = %d", g);
		LIGHTTHRESH = g + 300;
	}
	clearTimer(T1);
	while(time1[T1] < 5000){
			displayTextLine(5, "Place on start. LIGHTTHRESH = %d", LIGHTTHRESH);
	}
}

task main()
{
	init();

	while(true){

		long r, g, b;
		HTCS2readRawRGB(S3, true, r, g, b);

		startTask(findLine);
		startTask(lineFollow);
		startTask(avoid);
		startTask(observe);

		/** Look for line **/
		if(!found && !object){
			setMotorSpeed(leftMotor, 14);
			setMotorSpeed(rightMotor, 20);
		}

		/** follows the line **/
		if(found && !object){

			displayTextLine(1, "found");

			if(position == 0){ //On black
				setMotorSpeed(leftMotor, 20);
				setMotorSpeed(rightMotor, -15);
			}else if(position == 1){ //off
				setMotorSpeed(leftMotor, 3);
				setMotorSpeed(rightMotor, 20);
			}
		}

		/** Backs up, turns and goes round an object **/
		if(object){
			if(!turned){
				clearTimer(T3);
				while(time1[T3] < 1600){
					setMotorSpeed(leftMotor,-7);
					setMotorSpeed(rightMotor, -7);
				}
				clearTimer(T3);
				while(time1[T3] < 1200){
					setMotorSpeed(leftMotor,11);
					setMotorSpeed(rightMotor, -11);
				}
				turned = true;
			}

			setMotorSpeed(leftMotor,15);
			setMotorSpeed(rightMotor, 20);

		}

	}
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}
